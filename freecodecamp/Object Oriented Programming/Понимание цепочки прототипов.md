Понимание цепочки прототипов
Все объекты в JavaScript (за некоторыми исключениями) имеют расширение prototype. Кроме того, объект сам по prototypeсебе является объектом.

function Bird(name) {
  this.name = name;
}

typeof Bird.prototype;
Поскольку a prototypeявляется объектом, у a prototypeможет быть свой собственный prototype! В этом случае prototypeзначение Bird.prototypeравно Object.prototype:

Object.prototype.isPrototypeOf(Bird.prototype);
Чем это полезно? Вы можете вспомнить hasOwnPropertyметод из предыдущей задачи:

let duck = new Bird("Donald");
duck.hasOwnProperty("name");
Метод hasOwnPropertyопределен в Object.prototype, к которому можно получить доступ с помощью Bird.prototype, к которому затем можно получить доступ с помощью duck. Это пример prototypeцепочки. В этой prototypeцепочке for Bird, а . является для обоих и . для всех объектов в JavaScript. Следовательно, любой объект может использовать этот метод.supertypeduckducksubtypeObjectsupertypeBirdduckObjectsupertypehasOwnProperty

Измените код, чтобы показать правильную цепочку прототипов.

### Before
```javascript
function Dog(name) {
  this.name = name;
}

let beagle = new Dog("Snoopy");

Dog.prototype.isPrototypeOf(beagle);  // yields true

// Fix the code below so that it evaluates to true
???.isPrototypeOf(Dog.prototype);
```
### Answers
```javascript

```
