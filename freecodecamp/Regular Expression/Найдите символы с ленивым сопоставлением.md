# Найдите символы с ленивым сопоставлением
В регулярных выражениях жадное совпадение находит максимально длинную часть строки, которая соответствует шаблону регулярного выражения, и возвращает ее как совпадение. Альтернатива называется ленивым сопоставлением, которое находит наименьшую возможную часть строки, удовлетворяющую шаблону регулярного выражения.

Вы можете применить регулярное выражение `/t[a-z]*i/`к строке `"titanic"`. Это регулярное выражение в основном представляет собой шаблон, который начинается с `t`, заканчивается на `i`и имеет несколько букв между ними.

Регулярные выражения по умолчанию являются жадными, поэтому совпадение возвращает `["titani"]`. Он находит самую большую подстроку, соответствующую шаблону.

Однако вы можете использовать `?`символ, чтобы изменить его на ленивое сопоставление. `"titanic"`сопоставляется с скорректированным регулярным выражением `/t[a-z]*?i/return ["ti"]`.

Примечание. Следует избегать синтаксического анализа HTML с помощью регулярных выражений, но сопоставление шаблона строки HTML с регулярными выражениями вполне допустимо.

Исправьте регулярное выражение `/<.*>/`, чтобы оно возвращало тег HTML, `<h1>`а не текст `"<h1>Winter is coming</h1>"`. Помните, что подстановочный знак `.`в регулярном выражении соответствует любому символу.
### Before
```javascript
let text = "<h1>Winter is coming</h1>";
let myRegex = /<.*>/; // Change this line
let result = text.match(myRegex);
```
### Answers
```javascript
let text = "<h1>Winter is coming</h1>";
let myRegex = /<.*?>/; // Change this line
let result = text.match(myRegex);
```
## Проблема Объяснение
Исправьте регулярное выражение `/<.*>/`, чтобы оно возвращало тег HTML, `<h1>`а не текст `<h1>Winter is coming</h1>`. Запомните подстановочный знак. в регулярном выражении соответствует любому символу.

Решение
```javascript
let text = "<h1>Winter is coming</h1>";
let myRegex = /<.*?>/; // it's the answer!
let result = text.match(myRegex);
```


