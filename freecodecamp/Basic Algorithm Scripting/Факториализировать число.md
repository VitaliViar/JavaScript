# Факториализировать число
Возвращает факториал предоставленного целого числа.

Если целое число представлено буквой `n`, факториал представляет собой произведение всех положительных целых чисел, меньших или равных `n`.

Факториалы часто представляются в сокращенной записиn!

Например:`5! = 1 * 2 * 3 * 4 * 5 = 120`

В функцию будут переданы только целые числа, большие или равные нулю.

### Before
```javascript
function factorialize(num) {
  return num;
}

factorialize(5);
```
### Answers
```javascript

```

Подсказка 1
Вы знаете, что ваше решение должно возвращаться 1, когда число, переданное функции, равно 0или 1. Кроме того, окончательное возвращаемое значение будет произведением всех чисел от 1 до числа (включительно). Если вы инициализируете значение продукта равным 1, то подумайте, как вы могли бы начать с заданного числа и продолжать уменьшать это число до определенного значения, умножая произведение на число на каждом шаге.

Рекурсивное решение

Это начинается легко с 0! = 1, так что вы можете идти вперед и просто return 1там.

Мы можем использовать это if, чтобы разорвать цикл, который мы собираемся создать с помощью рекурсивной функции . Он проверит, равно ли число, которое вы дали функции, 0 (что будет концом вашей факториальной цепочки). Функции «заканчиваются», когда они что-то возвращают. На самом деле все функции без явного returnоператора возвращают значение undefined.

По этой же причине вместо « завершено» о функции всегда говорят «вернулось» . А теперь это…

Понимание рекурсии

Рекурсия относится к функции, повторяющей (вызывающей) себя. В этом случае мы в основном возвращаем заданное число (т.е. 5), умноженное на саму функцию, но на этот раз значение, переданное параметру num , равно num-1(которое первоначально преобразуется в 4). Сама функция будет запускаться внутри себя интересно, а?

Понимание потока

Первое возвращаемое значение можно визуализировать лучше, если вы вспомните те операции со скобками, которые вы выполняли в средней школе, когда вы выполняете математику внутри каждой скобки изнутри наружу, скобки и квадратной скобки, пока не получите окончательный результат (итого). На этот раз то же самое, посмотрите на ход программы:

При первом выполнении функции:

[ число = 5]

5 равно 1 или 0? Нет —> Оки доки, продолжим…

Возвращает:

( 5 _( второе исполнение : 4 _( третье исполнение : 3 _( четвертое исполнение : 2 _ пятое исполнение : 1 ))))

То, что она возвращает, можно рассматривать как (5*(4*(3*(2*1))))или просто 5 * 4 * 3 * 2 * 1, и функция вернет результат этой операции: 120. Теперь давайте проверим, что делают остальные исполнения:

Во время остальных казней :

Второе выполнение : число = 5-1 = 4 → число 0 или 1? Нет

→ вернуть умножение между 4 и следующим результатом, когда число теперь равно 4-1.

Третье выполнение : число = 4 - 1 = 3 → число 0 или 1? Нет

→ вернуть умножение между 3 и следующим результатом, когда число теперь равно 3-1.

Четвертое выполнение : num = 3-1 = 2 → num 0 или 1? Нет

→ вернуть умножение между 2 и следующим результатом, когда число теперь равно 2-1.

Пятое выполнение : число = 2-1 = 1 → число 0 или 1? Ага

→ вернуть 1 . И здесь рекурсия останавливается, потому что больше нет исполнений.

Соответствующи
