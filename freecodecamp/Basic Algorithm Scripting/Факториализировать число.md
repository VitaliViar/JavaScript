# Факториализировать число
Возвращает факториал предоставленного целого числа.

Если целое число представлено буквой `n`, факториал представляет собой произведение всех положительных целых чисел, меньших или равных `n`.

Факториалы часто представляются в сокращенной записиn!

Например:`5! = 1 * 2 * 3 * 4 * 5 = 120`

В функцию будут переданы только целые числа, большие или равные нулю.

### Before
```javascript
function factorialize(num) {
  return num;
}

factorialize(5);
```
### Answers
```javascript

```

## Факториализировать число

### Подсказка
Вы знаете, что ваше решение должно возвращаться `1`, когда число, переданное функции, равно `0`или `1`. Кроме того, окончательное возвращаемое значение будет произведением всех чисел от `1` до числа (включительно). Если вы инициализируете значение продукта равным `1`, то подумайте, как вы могли бы начать с заданного числа и продолжать уменьшать это число до определенного значения, умножая произведение на число на каждом шаге.

### Рекурсивное решение

Это начинается легко с `0! = 1`, так что вы можете идти вперед и просто `return 1`там.

Мы можем использовать это `if`, чтобы разорвать цикл, который мы собираемся создать с помощью рекурсивной функции . Он проверит, равно ли число, которое вы дали функции, `0` (что будет концом вашей факториальной цепочки). Функции «заканчиваются», когда они что-то возвращают. На самом деле все функции без явного `return`оператора возвращают значение `undefined`.

По этой же причине вместо « завершено» о функции всегда говорят «вернулось» . А теперь это…

### Понимание рекурсии

Рекурсия относится к функции, повторяющей (вызывающей) себя. В этом случае мы в основном возвращаем заданное число (т.е. `5`), умноженное на саму функцию, но на этот раз значение, переданное параметру `num` , равно `num-1`(которое первоначально преобразуется в `4`). Сама функция будет запускаться внутри себя интересно, а?

### Понимание потока

Первое возвращаемое значение можно визуализировать лучше, если вы вспомните те операции со скобками, которые вы выполняли в средней школе, когда вы выполняете математику внутри каждой скобки изнутри наружу, скобки и квадратной скобки, пока не получите окончательный результат (итого). На этот раз то же самое, посмотрите на ход программы:

### При первом выполнении функции:

`[ число = 5]`

`5` равно `1` или `0`? Нет `—>` Оки доки, продолжим…

### Возвращает:

( `5` _( второе исполнение : `4` _( третье исполнение : `3` _( четвертое исполнение : `2` _ пятое исполнение : `1` ))))

То, что она возвращает, можно рассматривать как `(5*(4*(3*(2*1))))`или просто `5 * 4 * 3 * 2 * 1`, и функция вернет результат этой операции: `120`. Теперь давайте проверим, что делают остальные исполнения:

### Во время остальных казней :

### Второе выполнение :
число `= 5-1 = 4 → `число `0` или `1`? Нет

→ вернуть умножение между `4` и следующим результатом, когда число теперь равно `4-1`.

Третье выполнение : число `= 4 - 1 = 3 →` число `0` или `1`? Нет

→ вернуть умножение между `3` и следующим результатом, когда число теперь равно `3-1`.

Четвертое выполнение : `num = 3-1 = 2 → num 0` или `1`? Нет

→ вернуть умножение между `2` и следующим результатом, когда число теперь равно `2-1`.

Пятое выполнение : число `= 2-1 = 1 → `число `0` или `1`? Ага

→ вернуть `1` . И здесь рекурсия останавливается, потому что больше нет исполнений.

Соответствующие ссылки
* [JS-функции](https://www.youtube.com/watch?v=R8SjM4DKK80) 
* [Рекурсия в JS](https://www.youtube.com/watch?v=k7-N8R0-KY4) 
### Решение 1
```javascript
function factorialize(num) {
  let product = 1;
  for (let i = 2; i <= num; i++) {
    product *= i;
  }
  return product;
}

factorialize(5);
```
## Код Пояснение
Поскольку возвращаемые значения для функции всегда будут больше или равны `1`, `product`инициализируется единицей. В случае, когда число равно `0`, условие цикла `for` будет ложным, но, поскольку `product`оно инициализируется как `1`, оно будет иметь правильное значение при выполнении `return`инструкции.

Для всех переданных в функцию чисел, которые больше единицы, простой `for`цикл будет увеличиваться `i`на единицу на каждой итерации и пересчитываться `product`до значения `num`.

### Решение 2
(используя рекурсию)
```javascript
function factorialize(num) {
  if (num === 0) {
    return 1;
  }
  return num * factorialize(num - 1);
}

factorialize(5);
```
## Код Пояснение
Обратите внимание, в первой строке у нас есть терминальное условие, т.е. условие для проверки конца рекурсии. Если `num == 0`, то мы возвращаем `1`, т.е. эффективно завершаем рекурсию и информируем стек о необходимости распространить это значение на верхние уровни. Если у нас нет этого условия, рекурсия будет продолжаться до тех пор, пока пространство стека не будет исчерпано, что приведет к [переполнению стека](https://en.wikipedia.org/wiki/Stack_overflow) .

### Решение 3
```javascript
function factorialize(num, factorial = 1) {
  if (num === 0) {
    return factorial;
  } else {
    return factorialize(num - 1, factorial * num);
  }
}

factorialize(5);
```
## Код Пояснение
В этом решении мы используем [хвостовую рекурсию](https://stackoverflow.com/questions/33923/what-is-tail-recursion) `774`оптимизировать использование памяти.

В традиционной головной рекурсии типичная модель заключается в том, что вы сначала выполняете свои рекурсивные вызовы, а затем берете возвращаемое значение рекурсивного вызова и вычисляете результат. Таким образом, вы не получите результат своего вычисления, пока не вернетесь из каждого рекурсивного вызова.

В хвостовой рекурсии вы сначала выполняете свои вычисления, а затем выполняете рекурсивный вызов, передавая результаты вашего текущего шага следующему рекурсивному шагу. Это приводит к тому, что последний оператор имеет вид (`return` (параметры рекурсивной функции)).

В этом решении при каждой оценке рекурсивного вызова факториал обновляется. Это отличается от решения с головной рекурсией, в котором все оценочные вычисления хранятся в стеке до тех пор, пока не будет достигнут базовый случай.


### Решение 4
```javascript
function factorialize(num) {
  return num < 0 ? 1 :
    new Array(num)
      .fill(undefined)
      .reduce((product, _, index) => product * (index + 1), 1);
}
factorialize(5);
```
## Код Пояснение
В этом решении мы использовали функцию «уменьшить», чтобы найти значение факториала числа.
Мы создали массив, который имеет длину `num`. И мы заполнили все элементы массива как `undefined`. В этом случае мы должны сделать это, потому что пустые массивы не могут быть сокращены. Кстати, вы можете заполнить массив по своему желанию. Это полностью зависит от вашего инженерного зрения.
При `reduce`вызове аккумулятора функции `product`это также наше конечное значение. Мы умножаем значение нашего индекса на продукт, чтобы найти `factorialзначение`.
Мы устанавливаем начальное значение продукта равным `1`, потому что, если оно было равно нулю, продукты всегда получают нулевое значение.
Также значение факториала не может быть рассчитано для отрицательных чисел, прежде всего, мы тестируем это.
