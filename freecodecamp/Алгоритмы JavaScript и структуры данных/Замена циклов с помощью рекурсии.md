# Замена циклов с помощью рекурсии
Рекурсия — это концепция, согласно которой функция может быть выражена через саму себя. Чтобы помочь понять это, начните с размышления о следующей задаче: умножьте первые `n`элементы массива, чтобы создать произведение этих элементов. Используя `fo`rцикл, вы можете сделать это:
```javascript
  function multiply(arr, n) {
    let product = 1;
    for (let i = 0; i < n; i++) {
      product *= arr[i];
    }
    return product;
  }
  ```
Однако обратите внимание на то `multiply(arr, n) == multiply(arr, n - 1) * arr[n - 1]`. Это означает, что вы можете переписать `multiply`с точки зрения самого себя и вам никогда не понадобится использовать цикл.
```javascript
  function multiply(arr, n) {
    if (n <= 0) {
      return 1;
    } else {
      return multiply(arr, n - 1) * arr[n - 1];
    }
  }
  ```
Рекурсивная версия `multiply`ломается следующим образом. В _базовом случае_ , где `n <= 0`, он возвращает 1. Для больших значений `n`он вызывает сам себя, но с `n - 1`. Этот вызов функции оценивается таким же образом, вызывая `multiply`снова до тех пор, пока `n <= 0`. В этот момент все функции могут вернуться, и оригинал `multiply`возвращает ответ.

### Примечание.
У рекурсивных функций должен быть базовый случай, когда они возвращаются без повторного вызова функции (в этом примере, когда `n <= 0`), иначе они никогда не смогут завершить выполнение.

## Instructions

Напишите рекурсивную функцию, `sum(arr, n)`которая возвращает сумму первых `n`элементов массива `arr`.

### Before

```javascript
function sum(arr, n) {
  // Only change code below this line

  // Only change code above this line
}
```
### Answers

```javascript
function sum(arr, n) {
  // Only change code below this line
  if (n <= 0) {
      return 0;
    } else {
      return sum(arr, n - 1) + arr[n - 1];
    }
  // Only change code above this line
}
```

### Код Пояснение
Оператор `if`проверяет, `sum`оценивает ли базовый случай `n <= 0`, или нет. Если да, то `sum`возвращает ответ, 0- сумму элементов от 0 до 0 включительно. В противном случае выполняется рекурсия путем вычисления более простого вызова функции `sum(arr, n - 1)`. Как только это возвращает, он добавляет к нему один элемент массива `arr[n - 1]`и возвращает эту сумму.

